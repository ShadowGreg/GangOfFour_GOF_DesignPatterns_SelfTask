[javarush.com
](https://javarush.com/groups/posts/3833-pattern-proektirovanija-dekorator-s-primerami)

[metanit
](https://metanit.com/sharp/patterns/4.1.php)

[csharptutorial.net
](https://www.csharptutorial.net/csharp-design-patterns/csharp-decorator-pattern/)


Паттерн проектирования декоратор позволяет нам динамически добавлять функциональность объекту без влияния на поведение
объектов того же самого класса. Звучит несколько запутанно, но когда увидите код все станет понятнее.

**Особенности**

— Декоратор позволяет добавлять функциональность существующему объекту без изменения его структуру, то есть исходный
класс не меняется
— Паттерн проектирования декоратор — это структурный паттерн, который обеспечивает обертку для существующего класса
— Создаются классы-декораторы, которые оборачивают исходный класс и предоставляют дополнительную функциональность,
сохраняя сигнатуры методов исходного класса нетронутыми
— Паттерн проектирования декоратор чаще всего используется для следования принципу единой ответственности (single
responsibility из SOLID), поскольку мы не нагружаем исходный класс дополнительными обязанностями, а разделяем их на
классы-декораторы
— Декоратор структурно почти аналогичен паттерну «цепочка ответственности» (chain of responsibility)

**Необходимо учитывать следующие ключевые моменты**

— Декоратор полезен для возможности модифицировать поведение объекта во время рантайма. Такой код легко поддерживать и
расширять.
— Недостатком этого паттерна является то, что используется большое количество однотипных объектов-декораторов
— Паттерн декоратор часто используется в классах Java IO (FileReader, BufferedReader и т. д.)

**Что сделаем**

— Создадим интерфейс
— Создадим конкретные реализации этого интерфейса
— Создадим абстрактный декоратор, реализующий этот интерфейс
— Создадим конкретный декоратор, наследующийся от абстрактного декоратора
— Используем конкретный декоратор для "декорирования" конкретных реализаций интерфейса
